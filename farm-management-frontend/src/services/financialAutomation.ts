import { collection, addDoc, onSnapshot, query, where, updateDoc, doc } from 'firebase/firestore';
import { db } from '../config/firebase';

class FinancialAutomation {
  private unsubscribers: (() => void)[] = [];

  // Auto-categorize transactions based on keywords
  private categorizationRules = {
    income: {
      'Crop Sales': ['harvest', 'sale', 'sold', 'crop', 'produce', 'vegetables', 'fruits'],
      'Livestock/Livestock Products Sale': ['livestock', 'cattle', 'chicken', 'eggs', 'milk', 'meat', 'poultry'],
      'Government Subsidy': ['subsidy', 'grant', 'government', 'support'],
      'Equipment Rental': ['rental', 'rent', 'lease'],
      'Other Income': []
    },
    expense: {
      'Seeds & Plants': ['seed', 'seedling', 'plant', 'sapling'],
      'Fertilizers': ['fertilizer', 'manure', 'compost', 'npk'],
      'Pesticides': ['pesticide', 'herbicide', 'insecticide', 'fungicide'],
      'Equipment': ['equipment', 'machinery', 'tractor', 'tools'],
      'Labor': ['labor', 'labour', 'worker', 'salary', 'wage', 'payment to'],
      'Utilities': ['electricity', 'water', 'fuel', 'diesel', 'petrol'],
      'Maintenance': ['repair', 'maintenance', 'service', 'fix'],
      'Transportation': ['transport', 'delivery', 'shipping', 'freight'],
      'Other Expenses': []
    }
  };

  autoCategorizTransaction(description: string, type: 'income' | 'expense'): string {
    const rules = this.categorizationRules[type];
    const lowerDesc = description.toLowerCase();

    for (const [category, keywords] of Object.entries(rules)) {
      if (keywords.some(keyword => lowerDesc.includes(keyword))) {
        return category;
      }
    }

    return type === 'income' ? 'Other Income' : 'Other Expenses';
  }

  // Auto-track crop sales as income
  monitorCropHarvests() {
    const unsubscribe = onSnapshot(collection(db, 'crops'), (snapshot) => {
      snapshot.docs.forEach(async (cropDoc) => {
        const crop: any = { id: cropDoc.id, ...cropDoc.data() };

        if (crop.status === 'harvested' && !crop.incomeRecorded) {
          const estimatedIncome = crop.expectedYield * (crop.pricePerUnit || 50);
          
          await addDoc(collection(db, 'financial'), {
            type: 'income',
            category: 'Crop Sales',
            amount: estimatedIncome,
            description: `Harvest sale: ${crop.name || crop.cropType}`,
            date: new Date(),
            fieldId: crop.fieldId,
            fieldName: crop.fieldName,
            autoGenerated: true,
            sourceId: crop.id,
            sourceType: 'crop_harvest'
          });

          await updateDoc(doc(db, 'crops', crop.id), { incomeRecorded: true });
        }
      });
    });
    this.unsubscribers.push(unsubscribe);
  }

  // Auto-track task completion costs as expenses
  monitorTaskCompletions() {
    const unsubscribe = onSnapshot(
      query(collection(db, 'tasks'), where('status', '==', 'completed')),
      (snapshot) => {
        snapshot.docs.forEach(async (taskDoc) => {
          const task: any = { id: taskDoc.id, ...taskDoc.data() };

          if (!task.expenseRecorded && task.estimatedCost) {
            const category = this.autoCategorizTransaction(task.title, 'expense');

            await addDoc(collection(db, 'financial'), {
              type: 'expense',
              category,
              amount: task.estimatedCost,
              description: `Task: ${task.title}`,
              date: task.completedAt || new Date(),
              fieldId: task.fieldId,
              fieldName: task.fieldName,
              autoGenerated: true,
              sourceId: task.id,
              sourceType: 'task_completion'
            });

            await updateDoc(doc(db, 'tasks', task.id), { expenseRecorded: true });
          }
        });
      }
    );
    this.unsubscribers.push(unsubscribe);
  }

  // Auto-track labour payments as expenses
  monitorLabourPayments() {
    const unsubscribe = onSnapshot(collection(db, 'labour'), (snapshot) => {
      snapshot.docs.forEach(async (labourDoc) => {
        const labour: any = { id: labourDoc.id, ...labourDoc.data() };

        // Track when labour record is marked as paid
        if (labour.status === 'paid' && !labour.expenseRecorded) {
          await addDoc(collection(db, 'financial'), {
            type: 'expense',
            category: 'Labor',
            amount: labour.totalPay || 0,
            description: `Labour: ${labour.workerName} - ${labour.workType} (${labour.hoursWorked}h @ KSh ${labour.ratePerHour}/h)`,
            date: labour.date || new Date(),
            fieldId: labour.farmId,
            fieldName: labour.farmName,
            autoGenerated: true,
            sourceId: labour.id,
            sourceType: 'labour_payment',
            workerName: labour.workerName,
            hoursWorked: labour.hoursWorked,
            ratePerHour: labour.ratePerHour
          });

          await updateDoc(doc(db, 'labour', labour.id), { expenseRecorded: true });
        }
      });
    });
    this.unsubscribers.push(unsubscribe);
  }

  // Auto-track inventory purchases as expenses
  monitorInventoryPurchases() {
    const unsubscribe = onSnapshot(collection(db, 'inventory'), (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === 'modified') {
          const item: any = { id: change.doc.id, ...change.doc.data() };
          const oldItem: any = change.doc.data();

          const quantityIncrease = item.quantity - (oldItem.quantity || 0);
          
          if (quantityIncrease > 0 && item.unitPrice) {
            const purchaseCost = quantityIncrease * item.unitPrice;
            const category = this.autoCategorizTransaction(item.name, 'expense');

            await addDoc(collection(db, 'financial'), {
              type: 'expense',
              category,
              amount: purchaseCost,
              description: `Purchased ${quantityIncrease} ${item.unit} of ${item.name}`,
              date: new Date(),
              autoGenerated: true,
              sourceId: item.id,
              sourceType: 'inventory_purchase',
              item: item.name,
              quantity: quantityIncrease,
              unitPrice: item.unitPrice
            });
          }
        }
      });
    });
    this.unsubscribers.push(unsubscribe);
  }

  // Generate monthly financial summary
  async generateMonthlySummary() {
    const now = new Date();
    const firstDay = new Date(now.getFullYear(), now.getMonth(), 1);
    const lastDay = new Date(now.getFullYear(), now.getMonth() + 1, 0);

    const q = query(
      collection(db, 'financial'),
      where('date', '>=', firstDay),
      where('date', '<=', lastDay)
    );

    return new Promise((resolve) => {
      onSnapshot(q, (snapshot) => {
        const records = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as any[];

        const income = records
          .filter(r => r.type === 'income')
          .reduce((sum, r) => sum + (r.amount || 0), 0);

        const expenses = records
          .filter(r => r.type === 'expense')
          .reduce((sum, r) => sum + (r.amount || 0), 0);

        const incomeByCategory: any = {};
        const expensesByCategory: any = {};

        records.forEach(r => {
          if (r.type === 'income') {
            incomeByCategory[r.category] = (incomeByCategory[r.category] || 0) + r.amount;
          } else {
            expensesByCategory[r.category] = (expensesByCategory[r.category] || 0) + r.amount;
          }
        });

        resolve({
          month: now.toLocaleString('default', { month: 'long', year: 'numeric' }),
          totalIncome: income,
          totalExpenses: expenses,
          netProfit: income - expenses,
          profitMargin: income > 0 ? ((income - expenses) / income * 100).toFixed(2) : 0,
          incomeByCategory,
          expensesByCategory,
          transactionCount: records.length
        });
      });
    });
  }

  // Auto-generate financial reports
  async autoGenerateReport() {
    const summary: any = await this.generateMonthlySummary();

    await addDoc(collection(db, 'financial_reports'), {
      ...summary,
      generatedAt: new Date(),
      type: 'monthly_summary'
    });

    return summary;
  }

  // Track capital in/out in real-time
  trackCapitalFlow() {
    const unsubscribe = onSnapshot(collection(db, 'financial'), (snapshot) => {
      const records = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as any[];

      const capitalIn = records
        .filter(r => r.type === 'income')
        .reduce((sum, r) => sum + (r.amount || 0), 0);

      const capitalOut = records
        .filter(r => r.type === 'expense')
        .reduce((sum, r) => sum + (r.amount || 0), 0);

      const netCapital = capitalIn - capitalOut;

      // Store in a summary document
      addDoc(collection(db, 'capital_summary'), {
        capitalIn,
        capitalOut,
        netCapital,
        timestamp: new Date(),
        status: netCapital >= 0 ? 'positive' : 'negative'
      });
    });

    this.unsubscribers.push(unsubscribe);
  }

  startAutomation() {
    this.monitorCropHarvests();
    this.monitorTaskCompletions();
    this.monitorLabourPayments();
    this.monitorInventoryPurchases();
    this.trackCapitalFlow();

    // Generate monthly report on the 1st of each month
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    const timeUntilNextMonth = nextMonth.getTime() - now.getTime();

    setTimeout(() => {
      this.autoGenerateReport();
      setInterval(() => this.autoGenerateReport(), 30 * 24 * 60 * 60 * 1000); // Every 30 days
    }, timeUntilNextMonth);

    console.log('Financial Automation started');
  }

  stopAutomation() {
    this.unsubscribers.forEach(unsubscribe => unsubscribe());
    this.unsubscribers = [];
    console.log('Financial Automation stopped');
  }
}

export const financialAutomation = new FinancialAutomation();
